<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Redis与mamcache区别redis常用命令积累 · Cheng yang's Blog</title><meta name="description" content="Redis与mamcache区别redis常用命令积累 - yangc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.yangcvo.me/atom.xml" title="Cheng yang's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/yangcvo" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/yangcvo" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="http://blog.yangcvo.me/2014/05/04/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/About-me/" target="_blank" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Redis与mamcache区别redis常用命令积累</h1><div class="post-info">2015年11月20日</div><div class="post-content"><h1 id="redis与mamcache区别-amp-redis常用命令积累"><a href="#redis与mamcache区别-amp-redis常用命令积累" class="headerlink" title="redis与mamcache区别&amp;redis常用命令积累"></a>redis与mamcache区别&amp;redis常用命令积累</h1><p>之前一直有在用mamcache集群，现在出来了redis用的多的还是现在的redis主从，集群等。</p>
<p>##redis与mamcache区别</p>
<p>也仔细了做了这两种存储数据库也叫内存数据库它们的区别：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、 Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等。</span><br><span class="line">2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，<span class="built_in">set</span>，<span class="built_in">hash</span>等数据结构的存储。</span><br><span class="line">3、虚拟内存--Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘</span><br><span class="line">4、过期策略--memcache在<span class="built_in">set</span>时就指定，例如<span class="built_in">set</span> key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10</span><br><span class="line">5、分布式--设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从</span><br><span class="line">6、存储数据安全--memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）</span><br><span class="line">7、灾难恢复--memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复</span><br><span class="line">8、Redis支持数据的备份，即master-slave模式的数据备份。</span><br></pre></td></tr></table></figure>
<p>redis优点：</p>
<p><code>有很好的存储数据安全功能，和灾难恢复，更加支撑Redis支持数据的备份。</code></p>
<p>而memcache优点：<code>memcache还可用于缓存其他东西，例如图片、视频等等。</code></p>
<p>##redis 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. redis查看当前所有的key</span><br><span class="line"></span><br><span class="line"> keys *  或  keys <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line">2. 查看当前redis的配置信息</span><br><span class="line"></span><br><span class="line"> CONFIG GET *</span><br><span class="line"></span><br><span class="line">3. 查看匹配前缀的keys</span><br><span class="line"></span><br><span class="line">keys <span class="string">"miao*"</span></span><br><span class="line"></span><br><span class="line">4. 清空redis</span><br><span class="line"></span><br><span class="line">flushdb</span><br><span class="line"></span><br><span class="line">5.随机取出一个key</span><br><span class="line"></span><br><span class="line">randomkey</span><br><span class="line"></span><br><span class="line">6. 查看key的类型</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> key</span><br><span class="line"></span><br><span class="line">7. 查看数据库中key的数量</span><br><span class="line"></span><br><span class="line">dbsize</span><br><span class="line"></span><br><span class="line">8. 查看服务器信息</span><br><span class="line"></span><br><span class="line">info</span><br><span class="line"></span><br><span class="line">9.查看redis正在做什么</span><br><span class="line"></span><br><span class="line">monitor</span><br><span class="line"></span><br><span class="line">10.查看日志</span><br><span class="line"></span><br><span class="line">slowlog get</span><br><span class="line">slowlog get 10</span><br></pre></td></tr></table></figure>
<p> redis是key-value存储的，放在内存中，并在磁盘持久化的数据结构存储系统，它可以用作数据库、缓存和消息中间件。</p>
<p>####1. 设置key的值,若存在则覆盖</p>
<p><code>set key value: key</code>设置key的值,若存在则覆盖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET yangc &quot;haozhuo&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get yangc</span><br><span class="line">&quot;haozhuo&quot;</span><br></pre></td></tr></table></figure>
<p>####2.redis提供原子自增操作incr,用来防止多线程并发出现数据错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">incr key:原子的+1；</span><br><span class="line">DECR key：原子的-1；</span><br><span class="line">DECRBY key integer：原子的-integer；</span><br><span class="line">INCRBY key integer：原子的+integer</span><br></pre></td></tr></table></figure>
<p>####3.删除操作：del.若数据不存在返回(nil)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; DEL yangc</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get yangc</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<p>####4.redis可以定时存储，即设置几秒后删除该变量</p>
<p><code>expire key</code>多少秒：设置多少秒后过期；  </p>
<p><code>ttl key:Time To Live</code>，查看还可以存活多久，-2表示key不存在；-1表示定时任务消失，永久存储。</p>
<p><code>EXPIRE key seconds</code>：设置该元素多少秒后失效</p>
<p><code>PEXPIRE key milliseconds</code>：设置该元素多少毫秒后失效</p>
<p><code>TTL key</code>：查看还可以存活多少秒，-2表示key不存在，-1表示永久存储</p>
<p><code>SETEX key seconds value</code>：等价于先设置变量再设置超时，即在缓存中使用：存储的同时设置超时时间，这个操作是原子的</p>
<p><code>persist key</code>:取消过期时间</p>
<p><code>expireat key 时间戳</code>：unix时间戳，1970.1.1之后，这个绝对时间，将在这个时间删除key。expireat<br>pages:about 1356933600：在2012年12月31日上午12点删除掉关键字</p>
<p><code>SETEX KEY_NAME TIMEOUT VALUE：</code>设置key的值为value，并在timeout秒后失效，key将被删除</p>
<p>####举例：</p>
<p>这里我举例了创建了一个key值，然后设置多少秒失效，查看的时候还有3秒，再次查看-2秒。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> yangc <span class="string">"youjiankan"</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXPIRE yangc 20</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get yangc</span><br><span class="line"><span class="string">"youjiankan"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line">127.0.0.1:6379&gt; ttl yangc</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ttl yangc</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; ttl yangc</span><br></pre></td></tr></table></figure>
<p>这个例子是设置多少秒失效取消时间后永久存储着，ttl查看是-1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> yangc <span class="string">"haopengyou"</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXPIRE yangc 40</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get yangc</span><br><span class="line"><span class="string">"haopengyou"</span></span><br><span class="line">127.0.0.1:6379&gt; ttl yangc</span><br><span class="line">(<span class="built_in">integer</span>) 34</span><br><span class="line">127.0.0.1:6379&gt; ttl yangc</span><br><span class="line">(<span class="built_in">integer</span>) 33</span><br><span class="line">127.0.0.1:6379&gt; ttl yangc</span><br><span class="line">(<span class="built_in">integer</span>) 32</span><br><span class="line">127.0.0.1:6379&gt; PERSIST yangc</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl yangc</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line">127.0.0.1:6379&gt; ttl yangc</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG SET logfile <span class="string">"/var/log/redis/redis-server.log"</span></span><br><span class="line">(error) ERR Unsupported CONFIG parameter: logfile</span><br></pre></td></tr></table></figure>
<p>logfile 不能通过set动态设置</p>
<p>####5.(error) OOM command not allowed when used memory &gt;<br>设置了maxmemory的选项,redis内存使用达到上限。<br>可以通过设置LRU算法来删除部分key,释放空间。<br>默认是按照过期时间的,如果set时候没有加上过期时间就会导致数据写满maxmemory。<br>如果不设置maxmemory或者设置为0 64位系统不限制内存，32位系统最多使用3GB内存。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">volatile-lru -&gt; 根据LRU算法生成的过期时间来删除。</span><br><span class="line">allkeys-lru -&gt; 根据LRU算法删除任何key。</span><br><span class="line">volatile-random -&gt; 根据过期设置来随机删除key。</span><br><span class="line">allkeys-&gt;random -&gt; 无差别随机删。</span><br><span class="line">volatile-ttl -&gt; 根据最近过期时间来删除（辅以TTL）</span><br><span class="line">noeviction -&gt; 谁也不删，直接在写操作时返回错误。</span><br></pre></td></tr></table></figure>
<p>####6. reids日志位置<br>logfile 日志记录方式，默认值为stdout，如果设置为stdout且以守护进程方式运行，那么日志会被重定向到/dev/null,也就是不记日志。</p>
<p>####7. reids配置参数详解</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#daemonize no  默认情况下， redis 不是在后台运行的，如果需要在后台运行，把该项的值更改为 yes</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="comment">#  当 redis 在后台运行的时候， Redis 默认会把 pid 文件放在 /var/run/redis.pid ，你可以配置到其他地址。</span></span><br><span class="line"><span class="comment">#  当运行多个 redis 服务时，需要指定不同的 pid 文件和端口</span></span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line"><span class="comment">#  指定 redis 运行的端口，默认是 6379</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="comment">#  在高并发的环境中，为避免慢客户端的连接问题，需要设置一个高速后台日志</span></span><br><span class="line">tcp-backlog 511</span><br><span class="line"><span class="comment">#  指定 redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求</span></span><br><span class="line"><span class="comment"># bind 192.168.1.100 10.0.0.1</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1</span></span><br><span class="line"><span class="comment">#  设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接</span></span><br><span class="line"><span class="comment"># 0 是关闭此设置</span></span><br><span class="line">timeout 0</span><br><span class="line"><span class="comment"># TCP keepalive</span></span><br><span class="line"><span class="comment">#  在 Linux 上，指定值（秒）用于发送 ACKs 的时间。注意关闭连接需要双倍的时间。默认为 0 。</span></span><br><span class="line">tcp-keepalive 0</span><br><span class="line"><span class="comment">#  指定日志记录级别，生产环境推荐 notice</span></span><br><span class="line"><span class="comment"># Redis 总共支持四个级别： debug 、 verbose 、 notice 、 warning ，默认为 verbose</span></span><br><span class="line"><span class="comment"># debug     记录很多信息，用于开发和测试</span></span><br><span class="line"><span class="comment"># varbose   有用的信息，不像 debug 会记录那么多</span></span><br><span class="line"><span class="comment"># notice    普通的 verbose ，常用于生产环境</span></span><br><span class="line"><span class="comment"># warning   只有非常重要或者严重的信息会记录到日志</span></span><br><span class="line">loglevel notice</span><br><span class="line"><span class="comment">#  配置 log 文件地址</span></span><br><span class="line"><span class="comment">#  默认值为 stdout ，标准输出，若后台模式会输出到 /dev/null 。</span></span><br><span class="line">logfile /var/<span class="built_in">log</span>/redis/redis.log</span><br><span class="line"><span class="comment">#  可用数据库数</span></span><br><span class="line"><span class="comment">#  默认值为 16 ，默认数据库为 0 ，数据库范围在 0- （ database-1 ）之间</span></span><br><span class="line">databases 16</span><br><span class="line"><span class="comment">################################ 快照#################################</span></span><br><span class="line"><span class="comment">#  保存数据到磁盘，格式如下 :</span></span><br><span class="line"><span class="comment">#   save &lt;seconds&gt; &lt;changes&gt;</span></span><br><span class="line"><span class="comment">#    指出在多长时间内，有多少次更新操作，就将数据同步到数据文件 rdb 。</span></span><br><span class="line"><span class="comment">#    相当于条件触发抓取快照，这个可以多个条件配合</span></span><br><span class="line"><span class="comment">#    比如默认配置文件中的设置，就设置了三个条件</span></span><br><span class="line"><span class="comment">#   save 900 1  900 秒内至少有 1 个 key 被改变</span></span><br><span class="line"><span class="comment">#   save 300 10  300 秒内至少有 300 个 key 被改变</span></span><br><span class="line"><span class="comment">#   save 60 10000  60 秒内至少有 10000 个 key 被改变</span></span><br><span class="line"><span class="comment"># save 900 1</span></span><br><span class="line"><span class="comment"># save 300 10</span></span><br><span class="line"><span class="comment"># save 60 10000</span></span><br><span class="line"><span class="comment">#  后台存储错误停止写。</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="comment">#  存储至本地数据库时（持久化到 rdb 文件）是否压缩数据，默认为 yes</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="comment"># RDB 文件的是否直接偶像 chcksum</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"><span class="comment">#  本地持久化数据库文件名，默认值为 dump.rdb</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="comment">#  工作目录</span></span><br><span class="line"><span class="comment">#  数据库镜像备份的文件放置的路径。</span></span><br><span class="line"><span class="comment">#  这里的路径跟文件名要分开配置是因为 redis 在进行备份时，先会将当前数据库的状态写入到一个临时文件中，等备份完成，</span></span><br><span class="line"><span class="comment">#  再把该该临时文件替换为上面所指定的文件，而这里的临时文件和上面所配置的备份文件都会放在这个指定的路径当中。</span></span><br><span class="line"><span class="comment"># AOF 文件也会存放在这个目录下面</span></span><br><span class="line"><span class="comment">#  注意这里必须制定一个目录而不是文件</span></span><br><span class="line">dir /var/lib/redis-server/</span><br><span class="line"><span class="comment">################################# 复制 #################################</span></span><br><span class="line"><span class="comment">#  主从复制 . 设置该数据库为其他数据库的从数据库 .</span></span><br><span class="line"><span class="comment">#  设置当本机为 slav 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</span></span><br><span class="line"><span class="comment"># slaveof &lt;masterip&gt;&lt;masterport&gt;</span></span><br><span class="line"><span class="comment">#  当 master 服务设置了密码保护时 ( 用 requirepass 制定的密码 )</span></span><br><span class="line"><span class="comment"># slave 服务连接 master 的密码</span></span><br><span class="line"><span class="comment"># masterauth &lt;master-password&gt;</span></span><br><span class="line"><span class="comment">#  当从库同主机失去连接或者复制正在进行，从机库有两种运行方式：</span></span><br><span class="line"><span class="comment"># 1)  如果 slave-serve-stale-data 设置为 yes( 默认设置 ) ，从库会继续响应客户端的请求</span></span><br><span class="line"><span class="comment"># 2)  如果 slave-serve-stale-data 是指为 no ，出去 INFO 和 SLAVOF 命令之外的任何请求都会返回一个</span></span><br><span class="line"><span class="comment">#     错误 "SYNC with master in progress"</span></span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"><span class="comment">#  配置 slave 实例是否接受写。写 slave 对存储短暂数据（在同 master 数据同步后可以很容易地被删除）是有用的，但未配置的情况下，客户端写可能会发送问题。</span></span><br><span class="line"><span class="comment">#  从 Redis2.6 后，默认 slave 为 read-only</span></span><br><span class="line">slaveread-only yes</span><br><span class="line"><span class="comment">#  从库会按照一个时间间隔向主库发送 PINGs. 可以通过 repl-ping-slave-period 设置这个时间间隔，默认是 10 秒</span></span><br><span class="line"><span class="comment"># repl-ping-slave-period 10</span></span><br><span class="line"><span class="comment"># repl-timeout  设置主库批量数据传输时间或者 ping 回复时间间隔，默认值是 60 秒</span></span><br><span class="line"><span class="comment">#  一定要确保 repl-timeout 大于 repl-ping-slave-period</span></span><br><span class="line"><span class="comment"># repl-timeout 60</span></span><br><span class="line"><span class="comment">#  在 slave socket 的 SYNC 后禁用 TCP_NODELAY</span></span><br><span class="line"><span class="comment">#  如果选择“ yes ” ,Redis 将使用一个较小的数字 TCP 数据包和更少的带宽将数据发送到 slave ， 但是这可能导致数据发送到 slave 端会有延迟 , 如果是 Linux kernel 的默认配置，会达到 40 毫秒 .</span></span><br><span class="line"><span class="comment">#  如果选择 "no" ，则发送数据到 slave 端的延迟会降低，但将使用更多的带宽用于复制 .</span></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"><span class="comment">#  设置复制的后台日志大小。</span></span><br><span class="line"><span class="comment">#  复制的后台日志越大， slave 断开连接及后来可能执行部分复制花的时间就越长。</span></span><br><span class="line"><span class="comment">#  后台日志在至少有一个 slave 连接时，仅仅分配一次。</span></span><br><span class="line"><span class="comment"># repl-backlog-size 1mb</span></span><br><span class="line"><span class="comment">#  在 master 不再连接 slave 后，后台日志将被释放。下面的配置定义从最后一个 slave 断开连接后需要释放的时间（秒）。</span></span><br><span class="line"><span class="comment"># 0 意味着从不释放后台日志</span></span><br><span class="line"><span class="comment"># repl-backlog-ttl 3600</span></span><br><span class="line"><span class="comment">#  如果 master 不能再正常工作，那么会在多个 slave 中，选择优先值最小的一个 slave 提升为 master ，优先值为 0 表示不能提升为 master 。</span></span><br><span class="line">slave-priority 100</span><br><span class="line"><span class="comment">#  如果少于 N 个 slave 连接，且延迟时间 &lt;=M 秒，则 master 可配置停止接受写操作。</span></span><br><span class="line"><span class="comment">#  例如需要至少 3 个 slave 连接，且延迟 &lt;=10 秒的配置：</span></span><br><span class="line"><span class="comment"># min-slaves-to-write 3</span></span><br><span class="line"><span class="comment"># min-slaves-max-lag 10</span></span><br><span class="line"><span class="comment">#  设置 0 为禁用</span></span><br><span class="line"><span class="comment">#   默认 min-slaves-to-write 为 0 （禁用）， min-slaves-max-lag 为 10</span></span><br><span class="line"><span class="comment">################################## 安全 ###################################</span></span><br><span class="line"><span class="comment">#  设置客户端连接后进行任何其他指定前需要使用的密码。</span></span><br><span class="line"><span class="comment">#  警告：因为 redis 速度相当快，所以在一台比较好的服务器下，一个外部的用户可以在一秒钟进行 150K 次的密码尝试，这意味着你需要指定非常非常强大的密码来防止暴力破解</span></span><br><span class="line"><span class="comment"># requirepass foobared</span></span><br><span class="line"><span class="comment">#  命令重命名 .</span></span><br><span class="line"><span class="comment">#  在一个共享环境下可以重命名相对危险的命令。比如把 CONFIG 重名为一个不容易猜测的字符。</span></span><br><span class="line"><span class="comment">#  举例 :</span></span><br><span class="line"><span class="comment"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span></span><br><span class="line"><span class="comment">#  如果想删除一个命令，直接把它重命名为一个空字符 "" 即可，如下：</span></span><br><span class="line"><span class="comment"># rename-command CONFIG ""</span></span><br><span class="line"><span class="comment">################################### 约束###################################</span></span><br><span class="line"><span class="comment">#设置同一时间最大客户端连接数，默认无限制， </span></span><br><span class="line"><span class="comment">#Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，</span></span><br><span class="line"><span class="comment">#如果设置  maxclients 0 ，表示不作限制。</span></span><br><span class="line"><span class="comment">#当客户端连接数到达限制时， Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</span></span><br><span class="line"><span class="comment"># maxclients 10000</span></span><br><span class="line"><span class="comment">#  指定 Redis 最大内存限制， Redis 在启动时会把数据加载到内存中，达到最大内存后， Redis 会按照清除策略尝试清除已到期的 Key</span></span><br><span class="line"><span class="comment">#  如果 Redis 依照策略清除后无法提供足够空间，或者策略设置为 ”noeviction” ，则使用更多空间的命令将会报错，例如 SET, LPUSH 等。但仍然可以进行读取操作</span></span><br><span class="line"><span class="comment">#  注意： Redis 新的 vm 机制，会把 Key 存放内存， Value 会存放在 swap 区</span></span><br><span class="line"><span class="comment">#  该选项对 LRU 策略很有用。</span></span><br><span class="line"><span class="comment"># maxmemory 的设置比较适合于把 redis 当作于类似 memcached 的缓存来使用，而不适合当做一个真实的 DB 。</span></span><br><span class="line"><span class="comment">#  当把 Redis 当做一个真实的数据库使用的时候，内存使用将是一个很大的开销</span></span><br><span class="line"><span class="comment"># maxmemory &lt;bytes&gt;</span></span><br><span class="line"><span class="comment">#  当内存达到最大值的时候 Redis 会选择删除哪些数据？有五种方式可供选择</span></span><br><span class="line"><span class="comment"># volatile-lru -&gt;  利用 LRU 算法移除设置过过期时间的 key (LRU: 最近使用  Least RecentlyUsed )</span></span><br><span class="line"><span class="comment"># allkeys-lru -&gt;  利用 LRU 算法移除任何 key</span></span><br><span class="line"><span class="comment"># volatile-random -&gt;  移除设置过过期时间的随机 key</span></span><br><span class="line"><span class="comment"># allkeys-&gt;random -&gt; remove a randomkey, any key</span></span><br><span class="line"><span class="comment"># volatile-ttl -&gt;  移除即将过期的 key(minor TTL)</span></span><br><span class="line"><span class="comment"># noeviction -&gt;  不移除任何可以，只是返回一个写错误</span></span><br><span class="line"><span class="comment">#  注意：对于上面的策略，如果没有合适的 key 可以移除，当写的时候 Redis 会返回一个错误</span></span><br><span class="line"><span class="comment">#  默认是 :  volatile-lru</span></span><br><span class="line"><span class="comment"># maxmemory-policy volatile-lru  </span></span><br><span class="line"><span class="comment"># LRU  和  minimal TTL 算法都不是精准的算法，但是相对精确的算法 ( 为了节省内存 ) ，随意你可以选择样本大小进行检测。</span></span><br><span class="line"><span class="comment"># Redis 默认的灰选择 3 个样本进行检测，你可以通过 maxmemory-samples 进行设置</span></span><br><span class="line"><span class="comment"># maxmemory-samples 3</span></span><br><span class="line"><span class="comment">############################## AOF###############################</span></span><br><span class="line"><span class="comment">#  默认情况下， redis 会在后台异步的把数据库镜像备份到磁盘，但是该备份是非常耗时的，而且备份也不能很频繁，如果发生诸如拉闸限电、拔插头等状况，那么将造成比较大范围的数据丢失。</span></span><br><span class="line"><span class="comment">#  所以 redis 提供了另外一种更加高效的数据库备份及灾难恢复方式。</span></span><br><span class="line"><span class="comment">#  开启 append only 模式之后， redis 会把所接收到的每一次写操作请求都追加到 appendonly.aof 文件中，当 redis 重新启动时，会从该文件恢复出之前的状态。</span></span><br><span class="line"><span class="comment">#  但是这样会造成 appendonly.aof 文件过大，所以 redis 还支持了 BGREWRITEAOF 指令，对 appendonly.aof 进行重新整理。</span></span><br><span class="line"><span class="comment">#  你可以同时开启 asynchronous dumps 和  AOF</span></span><br><span class="line">appendonly no</span><br><span class="line"><span class="comment"># AOF 文件名称  ( 默认 : "appendonly.aof")</span></span><br><span class="line"><span class="comment"># appendfilename appendonly.aof</span></span><br><span class="line"><span class="comment"># Redis 支持三种同步 AOF 文件的策略 :</span></span><br><span class="line"><span class="comment"># no:  不进行同步，系统去操作  . Faster.</span></span><br><span class="line"><span class="comment"># always: always 表示每次有写操作都进行同步 . Slow, Safest.</span></span><br><span class="line"><span class="comment"># everysec:  表示对写操作进行累积，每秒同步一次 . Compromise.</span></span><br><span class="line"><span class="comment">#  默认是 "everysec" ，按照速度和安全折中这是最好的。</span></span><br><span class="line"><span class="comment">#  如果想让 Redis 能更高效的运行，你也可以设置为 "no" ，让操作系统决定什么时候去执行</span></span><br><span class="line"><span class="comment">#  或者相反想让数据更安全你也可以设置为 "always"</span></span><br><span class="line"><span class="comment">#  如果不确定就用  "everysec".</span></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br><span class="line"><span class="comment"># AOF 策略设置为 always 或者 everysec 时，后台处理进程 ( 后台保存或者 AOF 日志重写 ) 会执行大量的 I/O 操作</span></span><br><span class="line"><span class="comment">#  在某些 Linux 配置中会阻止过长的 fsync() 请求。注意现在没有任何修复，即使 fsync 在另外一个线程进行处理</span></span><br><span class="line"><span class="comment">#  为了减缓这个问题，可以设置下面这个参数 no-appendfsync-on-rewrite</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"><span class="comment"># AOF  自动重写</span></span><br><span class="line"><span class="comment">#  当 AOF 文件增长到一定大小的时候 Redis 能够调用  BGREWRITEAOF  对日志文件进行重写</span></span><br><span class="line"><span class="comment">#  它是这样工作的： Redis 会记住上次进行些日志后文件的大小 ( 如果从开机以来还没进行过重写，那日子大小在开机的时候确定 )</span></span><br><span class="line"><span class="comment">#  基础大小会同现在的大小进行比较。如果现在的大小比基础大小大制定的百分比，重写功能将启动</span></span><br><span class="line"><span class="comment">#  同时需要指定一个最小大小用于 AOF 重写，这个用于阻止即使文件很小但是增长幅度很大也去重写 AOF 文件的情况</span></span><br><span class="line"><span class="comment">#  设置  percentage 为 0 就关闭这个特性</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"><span class="comment">################################ LUASCRIPTING #############################</span></span><br><span class="line"><span class="comment"># 一个 Lua 脚本最长的执行时间为 5000 毫秒（ 5 秒），如果为 0 或负数表示无限执行时间。</span></span><br><span class="line">lua-time-limit 5000</span><br><span class="line"><span class="comment">################################LOW LOG################################</span></span><br><span class="line"><span class="comment"># Redis Slow Log  记录超过特定执行时间的命令。执行时间不包括 I/O 计算比如连接客户端，返回结果等，只是命令执行时间</span></span><br><span class="line"><span class="comment">#  可以通过两个参数设置 slow log ：一个是告诉 Redis 执行超过多少时间被记录的参数 slowlog-log-slower-than( 微妙 ) ，</span></span><br><span class="line"><span class="comment">#  另一个是 slow log 的长度。当一个新命令被记录的时候最早的命令将被从队列中移除</span></span><br><span class="line"><span class="comment">#  下面的时间以微妙为单位，因此 1000000 代表一秒。</span></span><br><span class="line"><span class="comment">#  注意指定一个负数将关闭慢日志，而设置为 0 将强制每个命令都会记录</span></span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"><span class="comment">#  对日志长度没有限制，只是要注意它会消耗内存</span></span><br><span class="line"><span class="comment">#  可以通过  SLOWLOG RESET 回收被慢日志消耗的内存</span></span><br><span class="line"><span class="comment">#  推荐使用默认值 128 ，当慢日志超过 128 时，最先进入队列的记录会被踢出</span></span><br><span class="line">slowlog-max-len 128</span><br><span class="line"><span class="comment">################################  事件通知  #############################</span></span><br><span class="line"><span class="comment">#  当事件发生时， Redis 可以通知 Pub/Sub 客户端。</span></span><br><span class="line"><span class="comment">#  可以在下表中选择 Redis 要通知的事件类型。事件类型由单个字符来标识：</span></span><br><span class="line"><span class="comment"># K     Keyspace 事件，以 _keyspace@&lt;db&gt;_ 的前缀方式发布</span></span><br><span class="line"><span class="comment"># E     Keyevent 事件，以 _keysevent@&lt;db&gt;_ 的前缀方式发布</span></span><br><span class="line"><span class="comment"># g     通用事件（不指定类型），像 DEL, EXPIRE, RENAME, …</span></span><br><span class="line"><span class="comment"># $     String 命令</span></span><br><span class="line"><span class="comment"># s     Set 命令</span></span><br><span class="line"><span class="comment"># h     Hash 命令</span></span><br><span class="line"><span class="comment"># z     有序集合命令</span></span><br><span class="line"><span class="comment"># x     过期事件（每次 key 过期时生成）</span></span><br><span class="line"><span class="comment"># e     清除事件（当 key 在内存被清除时生成）</span></span><br><span class="line"><span class="comment"># A     g$lshzxe 的别称，因此 ”AKE” 意味着所有的事件</span></span><br><span class="line"><span class="comment"># notify-keyspace-events 带一个由 0 到多个字符组成的字符串参数。空字符串意思是通知被禁用。</span></span><br><span class="line"><span class="comment">#  例子：启用 list 和通用事件：</span></span><br><span class="line"><span class="comment"># notify-keyspace-events Elg</span></span><br><span class="line"><span class="comment">#  默认所用的通知被禁用，因为用户通常不需要改特性，并且该特性会有性能损耗。</span></span><br><span class="line"><span class="comment">#  注意如果你不指定至少 K 或 E 之一，不会发送任何事件。</span></span><br><span class="line">notify-keyspace-events “”</span><br><span class="line"><span class="comment">##############################  高级配置  ###############################</span></span><br><span class="line"><span class="comment">#  当 hash 中包含超过指定元素个数并且最大的元素没有超过临界时，</span></span><br><span class="line"><span class="comment"># hash 将以一种特殊的编码方式（大大减少内存使用）来存储，这里可以设置这两个临界值</span></span><br><span class="line"><span class="comment"># Redis Hash 对应 Value 内部实际就是一个 HashMap ，实际这里会有 2 种不同实现，</span></span><br><span class="line"><span class="comment">#  这个 Hash 的成员比较少时 Redis 为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的 HashMap 结构，对应的 valueredisObject 的 encoding 为 zipmap,</span></span><br><span class="line"><span class="comment">#  当成员数量增大时会自动转成真正的 HashMap, 此时 encoding 为 ht 。</span></span><br><span class="line"><span class="built_in">hash</span>-max-zipmap-entries 512</span><br><span class="line"><span class="built_in">hash</span>-max-zipmap-value 64  </span><br><span class="line"><span class="comment">#  和 Hash 一样，多个小的 list 以特定的方式编码来节省空间。</span></span><br><span class="line"><span class="comment"># list 数据类型节点值大小小于多少字节会采用紧凑存储格式。</span></span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line"><span class="comment"># set 数据类型内部数据如果全部是数值型，且包含多少节点以下会采用紧凑格式存储。</span></span><br><span class="line"><span class="built_in">set</span>-max-intset-entries 512</span><br><span class="line"><span class="comment">#  和 hashe 和 list 一样 , 排序的 set 在指定的长度内以指定编码方式存储以节省空间</span></span><br><span class="line"><span class="comment"># zsort 数据类型节点值大小小于多少字节会采用紧凑存储格式。</span></span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"><span class="comment"># Redis 将在每 100 毫秒时使用 1 毫秒的 CPU 时间来对 redis 的 hash 表进行重新 hash ，可以降低内存的使用</span></span><br><span class="line"><span class="comment">#  当你的使用场景中，有非常严格的实时性需要，不能够接受 Redis 时不时的对请求有 2 毫秒的延迟的话，把这项配置为 no 。</span></span><br><span class="line"><span class="comment">#  如果没有这么严格的实时性要求，可以设置为 yes ，以便能够尽可能快的释放内存</span></span><br><span class="line">activerehashing yes</span><br><span class="line"><span class="comment"># 客户端的输出缓冲区的限制，因为某种原因客户端从服务器读取数据的速度不够快，</span></span><br><span class="line"><span class="comment"># 可用于强制断开连接（一个常见的原因是一个发布 / 订阅客户端消费消息的速度无法赶上生产它们的速度）。</span></span><br><span class="line"><span class="comment">#  可以三种不同客户端的方式进行设置：</span></span><br><span class="line"><span class="comment"># normal -&gt;  正常客户端</span></span><br><span class="line"><span class="comment"># slave  -&gt; slave 和 MONITOR 客户端</span></span><br><span class="line"><span class="comment"># pubsub -&gt;  至少订阅了一个 pubsub channel 或 pattern 的客户端</span></span><br><span class="line"><span class="comment">#  每个 client-output-buffer-limit 语法 :</span></span><br><span class="line"><span class="comment"># client-output-buffer-limit &lt;class&gt;&lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span></span><br><span class="line"><span class="comment">#  一旦达到硬限制客户端会立即断开，或者达到软限制并保持达成的指定秒数（连续）。</span></span><br><span class="line"><span class="comment">#  例如，如果硬限制为 32 兆字节和软限制为 16 兆字节 /10 秒，客户端将会立即断开</span></span><br><span class="line"><span class="comment">#  如果输出缓冲区的大小达到 32 兆字节，客户端达到 16 兆字节和连续超过了限制 10 秒，也将断开连接。</span></span><br><span class="line"><span class="comment">#  默认 normal 客户端不做限制，因为他们在一个请求后未要求时（以推的方式）不接收数据，</span></span><br><span class="line"><span class="comment">#  只有异步客户端可能会出现请求数据的速度比它可以读取的速度快的场景。</span></span><br><span class="line"><span class="comment">#  把硬限制和软限制都设置为 0 来禁用该特性</span></span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb60</span><br><span class="line"><span class="comment"># Redis 调用内部函数来执行许多后台任务，如关闭客户端超时的连接，清除过期的 Key ，等等。</span></span><br><span class="line"><span class="comment">#  不是所有的任务都以相同的频率执行，但 Redis 依照指定的“ Hz ”值来执行检查任务。</span></span><br><span class="line"><span class="comment">#  默认情况下，“ Hz ”的被设定为 10 。</span></span><br><span class="line"><span class="comment">#  提高该值将在 Redis 空闲时使用更多的 CPU 时，但同时当有多个 key 同时到期会使 Redis 的反应更灵敏，以及超时可以更精确地处理。</span></span><br><span class="line"><span class="comment">#  范围是 1 到 500 之间，但是值超过 100 通常不是一个好主意。</span></span><br><span class="line"><span class="comment">#  大多数用户应该使用 10 这个预设值，只有在非常低的延迟的情况下有必要提高最大到 100 。</span></span><br><span class="line">hz 10  </span><br><span class="line"><span class="comment">#  当一个子节点重写 AOF 文件时，如果启用下面的选项，则文件每生成 32M 数据进行同步。</span></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>
<p>####8. redis修改持久化路径和日志路径<br>vim redis.conf<br>logfile /data/redis_cache/logs/redis.log #日志路径<br>dir /data/redis_cache #持久化路径，修改后 记得要把dump.rdb持久化文件拷贝到/data/redis_cache下</p>
<p>先杀掉redis，拷贝dump.rdb，启动</p>
<p>####9. 清redis缓存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli    <span class="comment">#进入</span></span><br><span class="line">dbsize</span><br><span class="line">flushall     <span class="comment">#执行</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
</div></article></div></section><footer><div class="paginator"><a href="/2015/11/24/centos7.1/centos7细节变化/" class="prev">PREV</a><a href="/2015/11/20/Redis/Redis安装报错-报错搜集/" class="next">NEXT</a></div><div data-thread-key="2015/11/20/Redis/Redis与mamcache区别redis常用命令积累/" data-title="Redis与mamcache区别redis常用命令积累" data-url="http://blog.yangcvo.me/2015/11/20/Redis/Redis与mamcache区别redis常用命令积累/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"true"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2014 - 2016 <a href="http://blog.yangcvo.me">yangc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yangcvo" target="_blank">Github-yangcvo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>